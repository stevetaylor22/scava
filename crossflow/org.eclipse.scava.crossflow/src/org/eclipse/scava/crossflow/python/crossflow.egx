rule Workflow2Class 
	transform w : Workflow {
	
	guard: w.appliesTo()
	
	parameters : Map{"w" = w,"package" = w.getPackageName("Python")}
	
	template : "workflow2class.egl"
	
	target : w.getPath() + w.name + ".py"
}

rule Type2Class 
	transform t : Type {
	
	guard : t.appliesTo() and t.impl.isUndefined() //and s.csvFile.isUndefined()
	
	template : "type2class.egl"
	
	target : t.getPath() + t.name + ".py"
}

rule CsvSource2Source
	transform t : CsvSource {

	guard: t.appliesTo()

	parameters : Map{"w" = t.eContainer()}

	template : "csvsource2source.egl"
	
	target : t.getImplPath() + t.name + ".py"	
	
	overwrite : false
}

rule CsvSink2Sink
	transform t : CsvSink {

	guard: t.appliesTo()

	parameters : Map{"w" = t.eContainer()}

	template : "csvsink2sink.egl"
	
	target : t.getImplPath() + t.name + ".py"	
	
	overwrite : false
}

@greedy
rule Task2BaseClass 
	transform t : Task {

	guard : t.appliesTo()
	
	parameters : Map{"w" = t.eContainer()}
	
	template : "task2baseclass.egl"
	
	target : t.getPath() + t.name + "Base.py"	
}

@greedy
rule Task2ImplClass 
	transform t : Task {
		
	guard : t.appliesTo()
		
	parameters : Map{"w" = t.eContainer(),"package" = t.eContainer().getPackageName("Python")}
	
	template : "task2implclass.egl"
	
	target : t.getImplPath() + t.name + ".py"
	
	overwrite : false
}

@greedy
rule Steam2Class 
	transform s : Stream {
	
	guard: s.appliesTo()
	
	parameters : Map{"w" = s.eContainer()}
	
	template : "stream2class.egl"
	
	target : s.getPath() + s.name + ".py"
}

@greedy
rule Steam2Consumer 
	transform s : Stream {
	
	guard: s.appliesTo()
	
	parameters : Map{"t" = Task}
	
	template : "stream2consumer.egl"
	
	target : s.getPath() + s.name + "Consumer.py"
}

@cached
operation Any getPath() {
	var workflow = self.getWorkflow();
	var lang = workflow.languages.select(l|l.isPython());
	
	if (lang.isEmpty()) {
		return "python/src-gen" + "/" + workflow.package.toPath();
	} 

	return lang.first.genOutputFolder + "/" + lang.first.package.toPath();
}

@cached
operation Any getImplPath() {
	var workflow = self.getWorkflow();
	var lang = workflow.languages.select(l|l.isPython());
	
	if (lang.isEmpty()) {
		return "python/src" + "/" + workflow.package.toPath();
	} 

	return lang.first.outputFolder + "/" + lang.first.package.toPath();
}

@cached
operation Any getWorkflow() : Workflow {
	if (self.isTypeOf(Workflow)) return self;
	return self.eContainer().getWorkflow();
}

operation String toPath() : String {
	return self.replaceAll("\\.", "/") + "/";
}

operation Any appliesTo() : Boolean {
	if (self.isKindOf(Task)) {
		return self.languages.exists(l | l.isPython());
	}
	return not self.getWorkflow().languages.exists(l | l.isPython());
}

operation Workflow getPackageName(lang : String) {
	var lang = self.languages.selectOne(l | l.name == lang);
	if (lang.isDefined()) return langs.first.package;
	else return self.name.ftlc();
}

operation Language isPython() : Boolean {
	return self.name.toLowerCase == "python";
}